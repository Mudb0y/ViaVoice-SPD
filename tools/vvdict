#!/usr/bin/env python3
"""vvdict — Pronunciation dictionary tool for ViaVoice TTS.

Manages config/main.dict with plain-text respellings that ViaVoice reads
instead of the original word.  Uses CMU Pronouncing Dictionary as a
pronunciation reference.

Usage:
    vvdict add <word>        Add a pronunciation override (interactive)
    vvdict rm <word>         Remove an entry
    vvdict list              Show all entries
    vvdict search <pattern>  Search CMUdict for substring matches
"""

import argparse
import os
import re
import sys
import urllib.request

# --- Paths (relative to this script's location) ---
SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
ROOT_DIR = os.path.dirname(SCRIPT_DIR)
DICT_FILE = os.path.join(ROOT_DIR, "config", "main.dict")
CMUDICT_FILE = os.path.join(ROOT_DIR, "data", "cmudict.txt")
CMUDICT_URL = "https://raw.githubusercontent.com/cmusphinx/cmudict/master/cmudict.dict"

# --- ARPABET → readable respelling (rough approximation) ---
ARPABET_RESPELLING = {
    "AA": "ah",   # father
    "AE": "a",    # bat
    "AH": "uh",   # but / sofa (schwa)
    "AO": "aw",   # bought
    "AW": "ow",   # out
    "AY": "eye",  # bite
    "B":  "b",
    "CH": "ch",
    "D":  "d",
    "DH": "th",   # this
    "EH": "eh",   # bet
    "ER": "er",   # bird
    "EY": "ay",   # bait
    "F":  "f",
    "G":  "g",
    "HH": "h",
    "IH": "ih",   # bit
    "IY": "ee",   # beet
    "JH": "j",
    "K":  "k",
    "L":  "l",
    "M":  "m",
    "N":  "n",
    "NG": "ng",   # sing
    "OW": "oh",   # boat
    "OY": "oy",   # boy
    "P":  "p",
    "R":  "r",
    "S":  "s",
    "SH": "sh",   # ship
    "T":  "t",
    "TH": "th",   # thin
    "UH": "uu",   # book
    "UW": "oo",   # boot
    "V":  "v",
    "W":  "w",
    "Y":  "y",
    "Z":  "z",
    "ZH": "zh",   # measure
}

# Vowel phonemes (used for syllable grouping)
VOWELS = {
    "AA", "AE", "AH", "AO", "AW", "AY", "EH", "ER", "EY",
    "IH", "IY", "OW", "OY", "UH", "UW",
}


def arpabet_to_respelling(phones):
    """Convert ARPABET phones to a rough English respelling.

    Groups consonants with the following vowel to form syllables,
    separated by hyphens.  Purely a hint — users should tweak it.
    """
    syllables = []
    current = []
    for phone in phones:
        base = phone.rstrip("012")
        part = ARPABET_RESPELLING.get(base, base.lower())
        is_vowel = base in VOWELS
        if is_vowel and current:
            # Check if there are consonants to split: keep last consonant
            # with this vowel (onset), rest stay with previous syllable
            vowel_in_current = any(p[1] for p in current)
            if vowel_in_current and len(current) >= 1:
                # Split: move trailing consonants to new syllable
                trail = []
                while current and not current[-1][1]:
                    trail.insert(0, current.pop())
                if current:
                    syllables.append("".join(p[0] for p in current))
                current = trail
        current.append((part, base in VOWELS))
    if current:
        syllables.append("".join(p[0] for p in current))
    return " ".join(syllables)


def ensure_cmudict():
    """Download CMUdict if not cached locally. Returns path to the file."""
    if os.path.isfile(CMUDICT_FILE):
        return CMUDICT_FILE

    os.makedirs(os.path.dirname(CMUDICT_FILE), exist_ok=True)
    print(f"Downloading CMU Pronouncing Dictionary...", file=sys.stderr)
    print(f"  URL: {CMUDICT_URL}", file=sys.stderr)
    try:
        urllib.request.urlretrieve(CMUDICT_URL, CMUDICT_FILE)
    except Exception as e:
        # Clean up partial download
        if os.path.exists(CMUDICT_FILE):
            os.remove(CMUDICT_FILE)
        print(f"Error: Failed to download CMUdict: {e}", file=sys.stderr)
        sys.exit(1)
    print(f"  Saved to {CMUDICT_FILE}", file=sys.stderr)
    return CMUDICT_FILE


def load_cmudict():
    """Load CMUdict into a dict: word → list of phone-lists.

    CMUdict format: word  PH1 PH2 PH3
    Variants:       word(2)  PH1 PH2
    """
    path = ensure_cmudict()
    entries = {}
    with open(path, "r", encoding="utf-8") as f:
        for line in f:
            line = line.strip()
            if not line or line.startswith(";;;"):
                continue
            # Split on two-space separator (cmudict.dict format)
            parts = line.split("  ", 1)
            if len(parts) != 2:
                # Try single-space split as fallback
                parts = line.split(None, 1)
                if len(parts) != 2:
                    continue
            word_raw, phones_str = parts[0], parts[1]
            # Strip variant number: WORD(2) → WORD
            word = re.sub(r"\(\d+\)$", "", word_raw).upper()
            phones = phones_str.strip().split()
            entries.setdefault(word, []).append(phones)
    return entries


def load_dict():
    """Load config/main.dict into an ordered dict: word → translation."""
    entries = {}
    if not os.path.isfile(DICT_FILE):
        return entries
    with open(DICT_FILE, "r", encoding="utf-8") as f:
        for line in f:
            line = line.rstrip("\n")
            if not line:
                continue
            parts = line.split("\t", 1)
            if len(parts) == 2:
                entries[parts[0]] = parts[1]
    return entries


def save_dict(entries):
    """Save entries to config/main.dict, sorted alphabetically."""
    os.makedirs(os.path.dirname(DICT_FILE), exist_ok=True)
    with open(DICT_FILE, "w", encoding="utf-8") as f:
        for word in sorted(entries.keys(), key=str.lower):
            f.write(f"{word}\t{entries[word]}\n")


def cmd_add(args):
    """Interactive add command."""
    word = args.word.strip()
    if not word:
        print("Error: empty word", file=sys.stderr)
        sys.exit(1)

    # Check if already in dict
    entries = load_dict()
    if word in entries:
        print(f'\n  "{word}" already in dictionary:')
        print(f"    {word} → {entries[word]}")
        try:
            reply = input("\n  Overwrite? [y/N]: ").strip().lower()
        except (EOFError, KeyboardInterrupt):
            print("\n  Cancelled.")
            return
        if reply != "y":
            print("  Cancelled.")
            return

    # Look up in CMUdict
    cmudict = load_cmudict()
    lookup = word.upper()
    matches = cmudict.get(lookup, [])

    if matches:
        print(f'\n  CMUdict pronunciations for "{word}":')
        for i, phones in enumerate(matches, 1):
            arpabet_str = " ".join(phones)
            hint = arpabet_to_respelling(phones)
            print(f"    {i}) {arpabet_str:<30} ≈ {hint}")
        print()
        print("  Enter a number to use that respelling, or type your own.")
        print("  (q to cancel)")
        default = "1"
    else:
        print(f'\n  "{word}" not found in CMUdict.')
        print("  Type the respelling ViaVoice should say instead.")
        print("  (q to cancel)")
        default = None

    try:
        prompt = f"  Respelling [{default}]: " if default else "  Respelling: "
        choice = input(prompt).strip()
        if not choice and default:
            choice = default
    except (EOFError, KeyboardInterrupt):
        print("\n  Cancelled.")
        return

    if not choice or choice == "q":
        print("  Cancelled.")
        return

    # Check if it's a number selecting a CMUdict variant
    if matches and choice.isdigit():
        idx = int(choice) - 1
        if idx < 0 or idx >= len(matches):
            print(f"  Invalid choice: {choice}")
            return
        translation = arpabet_to_respelling(matches[idx])
    else:
        translation = choice

    entries[word] = translation
    save_dict(entries)
    print(f"  Added: {word} → {translation}")


def cmd_rm(args):
    """Remove a word from the dictionary."""
    word = args.word.strip()
    entries = load_dict()
    if word not in entries:
        print(f'  "{word}" not in dictionary.')
        return
    del entries[word]
    save_dict(entries)
    print(f'  Removed: {word}')


def cmd_list(args):
    """List all dictionary entries."""
    entries = load_dict()
    if not entries:
        print("  Dictionary is empty.")
        return
    for word in sorted(entries.keys(), key=str.lower):
        print(f"  {word}\t{entries[word]}")


def cmd_search(args):
    """Search CMUdict for substring matches."""
    pattern = args.pattern.strip().upper()
    if not pattern:
        print("Error: empty search pattern", file=sys.stderr)
        sys.exit(1)

    cmudict = load_cmudict()
    matches = []
    for word, phone_lists in sorted(cmudict.items()):
        if pattern in word:
            matches.append((word, phone_lists))

    if not matches:
        print(f'  No CMUdict entries matching "{args.pattern.strip()}".')
        return

    print(f'\n  CMUdict entries matching "{args.pattern.strip()}" ({len(matches)} results):')
    limit = 50
    for word, phone_lists in matches[:limit]:
        for phones in phone_lists:
            arpabet_str = " ".join(phones)
            hint = arpabet_to_respelling(phones)
            print(f"    {word.lower():<20} {arpabet_str:<30} ≈ {hint}")
    if len(matches) > limit:
        print(f"    ... and {len(matches) - limit} more (refine your search)")


def main():
    parser = argparse.ArgumentParser(
        prog="vvdict",
        description="Pronunciation dictionary tool for ViaVoice TTS",
    )
    sub = parser.add_subparsers(dest="command")

    p_add = sub.add_parser("add", help="Add a pronunciation override")
    p_add.add_argument("word", help="Word to add")

    p_rm = sub.add_parser("rm", help="Remove an entry")
    p_rm.add_argument("word", help="Word to remove")

    sub.add_parser("list", help="Show all entries")

    p_search = sub.add_parser("search", help="Search CMUdict")
    p_search.add_argument("pattern", help="Substring to search for")

    args = parser.parse_args()

    if args.command is None:
        parser.print_help()
        sys.exit(1)

    commands = {
        "add": cmd_add,
        "rm": cmd_rm,
        "list": cmd_list,
        "search": cmd_search,
    }
    commands[args.command](args)


if __name__ == "__main__":
    main()
